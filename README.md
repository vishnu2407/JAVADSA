**Strings In Depth:**
- Intro to Strings
- StringBuilder in Java
- String Concatenation in Java
- String Comparisons in Java
- String Reversing in Java
- String Splitting in Java
- String Trimming in Java
- String to Integer Conversion in Java
- String to Double Conversion in Java
- String to Boolean Conversion in Java
- String to Character Array in Java
- String to Byte Array in Java
- String to Short Array in Java
- String to Integer Array in Java
- String to Long Array in Java
- String to Float Array in Java
- String to Double Array in Java
- String to Boolean Array in Java
- String to Object Array in Java
- String to String Array in Java
- String to List in Java
- String to Set in Java
- String to Map in Java
- String to Properties in Java
- String to URL in Java
- String to URI in Java
- String to Date in Java
- String to Calendar in Java
- String to BigInteger in Java
- String to BigDecimal in Java
- String to Enum in Java
- String to UUID in Java
- String to InetAddress in Java
- String to Charset in Java
- String to Currency in Java
- String to Locale in Java
- String to TimeZone in Java
- String to Calendar in Java
- String to StringBuilder in Java
- String to StringBuffer in Java
- String to RandomAccess in Java
- String to Comparable in Java
- String to Comparator in Java
- String to Pattern in Java
- String to InetAddress in Java
- String to Charset in Java
- String to Currency in Java
- String to Locale in Java
- String to TimeZone in Java
- String to Calendar in Java
- String to BigInteger in Java
- String to BigDecimal in Java
- String to Enum in Java
- String to UUID in Java
- String to InetAddress in Java
- String to Charset in Java
- String to Currency in Java
- String to Locale in Java
- String to TimeZone in Java
- String to Calendar in Java
- String to StringBuilder in Java
- String to StringBuffer in Java

**String Constructors:**
- String()
- String(byte[] bytes)
- String(byte[] bytes, int offset, int length)
- String(byte[] bytes, Charset charset)
- String(byte[] bytes, int offset, int length, Charset charset)
- String(char[] value)
- String(char[] value, int offset, int count)
- String(String original)
- String(StringBuffer sb)
- String(StringBuilder sb)
- String(byte[] bytes, int offset, int length, String charsetName)
- String(byte[] bytes, String charsetName)
- String(byte[] bytes, Charset charset)
- String(byte[] bytes, int offset, int length, Charset charset)
- String(char[] value, int offset, int count)

**String Builder:**
- StringBuilder()
- StringBuilder(int capacity)
- append()
- append(boolean b)
- append(char c)
- append(char[] str)
- append(char[] str, int offset, int len)
- append(double d)
- append(float f)
- append(int i)
- append(long lng)
- append(Object obj)
- append(String str)
- append(StringBuffer sb)
- append(StringBuilder sb)
- appendCodePoint(int codePoint)
- delete(int start, int end)
- deleteCharAt(int index)
- insert(int index, boolean b)
- insert(int index, char c)
- insert(int index, char[] str)
- insert(int index, char[] str, int offset, int len)
- insert(int index, double d)
- insert(int index, float f)
- insert(int index, int i)
- insert(int index, long l)
- insert(int index, Object obj)
- insert(int index, String str)
- insert(int index, StringBuffer sb)
- insert(int index, StringBuilder sb)
- replace(int start, int end, String str)
- reverse()
- setCharAt(int index, char ch)
- setLength(int newLength)
- toString()
- capacity()
- length()
- charAt(int index)
- codePointAt(int index)
- codePointBefore(int index)
- codePointCount(int beginIndex, int endIndex)
- offsetByCodePoints(int index, int codePointOffset)
- substring(int start)
- substring(int start, int end)
- subSequence(int start, int end)
- trimToSize()
- ensureCapacity(int minimumCapacity)
- indexOf(String str)
- indexOf(String str, int fromIndex)
- lastIndexOf(String str)
- lastIndexOf(String str, int fromIndex)
- equals(Object anObject)
- hashCode()
- compareTo(String anotherString)
- compareToIgnoreCase(String str)
- isEmpty()
- isBlank()
- isDigit()
- isLetter()
- isLetterOrDigit()
- isLowerCase()
- isUpperCase()
- isWhitespace()
- matches(String regex)
- replaceAll(String regex, String replacement)
- replaceFirst(String regex, String replacement)
- split(String regex)
- split(String regex, int limit)
- toCharArray()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()
- valueOf(boolean b)
- valueOf(char c)
- valueOf(char[] data)
- valueOf(char[] data, int offset, int count)
- valueOf(double d)
- valueOf(float f)
- valueOf(int i)
- valueOf(long l)
- valueOf(Object obj)
- valueOf(String s)
- valueOf(StringBuffer sb)
- valueOf(StringBuilder sb)
- toCharArray()
- toCharArray(int srcBegin, int srcEnd)
- toString()
- toLowerCase()
- toUpperCase()
- trim()


**String Methods:**
- String.charAt()
- String.equals()
- String.equalsIgnoreCase()
- String.compareTo()
- String.compareToIgnoreCase()
- String.concat()
- String.contains()
- String.endsWith()
- String.equalsIgnoreCase()
- String.getBytes()
- String.getBytes(String charsetName)
- String.getBytes(Charset charset)
- String.getChars()
- String.indexOf()
- String.lastIndexOf()
- String.length()
- String.matches()
- String.replace()
- String.replaceAll()
- String.replaceFirst()
- String.split()
- String.startsWith()
- String.substring()
- String.toLowerCase()
- String.toUpperCase()
- String.trim()
- String.valueOf()
- String.valueOf(boolean b)
- String.valueOf(char c)
- String.valueOf(char[] data)
- String.valueOf(char[] data, int offset, int count)
- String.valueOf(double d)
- String.valueOf(float f)
- String.valueOf(int i)
- String.valueOf(long l)
- String.valueOf(Object obj)
- String.valueOf(String s)
- String.valueOf(StringBuffer sb)
- String.valueOf(StringBuilder sb)
- String.toCharArray()
- String.toCharArray(int srcBegin, int srcEnd)
- String.toString()
- String.toUpperCase()
- String.toLowerCase()
- String.toCharArray()


**Arrays**:
- Introduction to Arrays
- ArrayList In Java
- Printing Patterns
- Boyer-Moore Majority Voting Algorithm
- Sub-arrays
- Jagged Arrays
- **Time and Space Complexity Analysis of Arrays**:
  - Read: O(1)
  - Insertion: O(n)
  - Deletion: O(n)
  - Fast at reading but slow at insertion and deletion.


**Linked Lists:**
- Introduction to Data Structures
- Introduction to Linked List
- Read: O(n)
- Insertion: O(1)
- Deletion: O(1)
- Slow at reading but efficient for insertion and deletion.

**Hashmap:**
Introduction to Hashmap
- Read: O(1)
- Insertion: O(1)
- Deletion: O(1)
- Similar to arrays but with named indexes (keys); unordered but provide fast lookup.
- Useful for tasks like dictionary implementations.
- Hashmaps are often used in caching, where the data is frequently accessed and the cost of accessing the data is high.
- Hashmaps are also used in database indexing, where the data is frequently searched and the cost of searching the data is high.
- Hashmaps are also used in data structures like sets and maps, where the data is frequently searched and the cost of searching the data is high.
- Hashmaps are also used in algorithms like BFS and DFS, where the data is frequently accessed and the cost of accessing the data is high.

**Heaps:**
Introduction to Heaps
- A data structure that stores a collection of elements in a specific order.
- Heaps are useful for tasks like sorting, graph algorithms, and scheduling.
- Heaps are often implemented using an array or a binary tree.
- Heaps can be used to implement priority queues, which are often used in scheduling algorithms.
- Heaps can be used to implement heapsort, which is a popular sorting algorithm.
- Heaps can be used to implement Dijkstra's shortest path algorithm, which is a popular graph algorithm.
- Heaps can be used to implement the heap data structure used in the heapsort algorithm.

**Intro to Stack**:
- Push: O(1)
- Pop: O(1)
- Peak: O(1)
- Follow the LIFO (Last In, First Out) principle; useful for fast retrieval of the topmost element but can be cumbersome for inserting or deleting elements in the middle or end.

**Intro to Queues**:
- Enqueue: O(1)
- Dequeue: O(1)
- Front: O(1)
- Follow the FIFO (First In, First Out) principle; the first element in line is the first to come out. Think of them as playlists for organizing items in order of arrival.


**Trees:**
Intro to Trees
- Read/Search: O(log n)
- Insertion: O(log n)
- Deletion: O(log n)
- Nodes connected by edges; root, parent-child connections.


**Binary Tree:**
Intro to Binary Tree
- Efficient searching of ordered values.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Useful for tasks like number guessing games or dictionary implementations.


**Binary Search Tree:**
Intro to BST
- Efficient searching of ordered values.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Useful for tasks like number guessing games or dictionary implementations.

**AVL Tree:**
Introduction to AVL Tree
- A self-balancing binary search tree.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Balancing is done by maintaining a balance factor for each node.
- AVL Tree is a good choice for balanced trees.

**Red-Black Tree:**
Introduction to Red-Black Tree
- A self-balancing binary search tree.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Balancing is done by maintaining a balance factor for each node.
- Red-Black Tree is a good choice for balanced trees.

**Trie:**
Introduction to Trie
- A tree-like data structure used for efficient string searching.
- Each node represents a character in the string.
- Each edge represents a character.
- The root represents an empty string.
- The leaf nodes represent the end of a string.
- Tries are useful for tasks like autocomplete or spell checking.
- Tries are also used in spell checking and autocomplete.
- Tries are also used in autocomplete to suggest words based on the characters entered so far.
- Tries are also used in spell checking to suggest corrections based on the misspelled word.
- Tries are a type of data structure that is used for efficient string searching.
- Tries are often used in autocomplete to suggest words based on the characters entered so far.
- Tries are often used in tasks like routing, social networks, and pathfinding.



**Graphs:**
Introduction to Graphs
- Traversal/Search: O(V + E) (V: number of vertices, E: number of edges)
- Insertion: O(1)
- Deletion: O(1)
- Versatile models for connections between nodes and edges; can be directed or undirected with no neighboring limit. Can include cycles and weights on paths. Used for tasks like route optimization.
- Graphs are used in tasks like routing, social networks, and pathfinding.
- Graphs are used in tasks like clustering, community detection, and recommendation systems.
- Graphs are used in tasks like social networks, routing, and pathfinding.
- Graphs are used in tasks like clustering, community detection, and recommendation systems.
- Graphs are used in tasks like social networks, routing, and pathfinding.


**Searching & Sorting:**
- Linear Search
- Binary Search
- Bubble Sort
- Selection Sort
- Insertion Sort
- Count Sort
- Radix Sort
- Cyclic Sort
- Practise Questions

**Space & Time Complexity Analysis:**
- Time Complexity
- Space Complexity
- Recurrence Relations
- Time Space Tradeoff

**Recursion:**
- Intro to Recursion
- Flow of Recursion & Array
- Recursion & Strings
- Merge Sort
- Quick Sort
- Standard Practise Questions

**BackTracking In Java:**
Introduction to Backtracking
Sudoku Solver
- N Queens
- N Knight
- Maze Problems

**Maths for DSA:**
- Introduction to Maths in DSA
- Complete Bitwise Operators
- Modulo Arithmetic
- GCD and LCM
- Prime Numbers
- Euclid's Algorithm
- Euler's Totient Function
- Fibonacci Numbers
- Factorial
- Combinatorics
- Probability and Statistics
- Number Systems
- Number Theory
- Linear Algebra
- Complex Numbers
- Trigonometry
- Graph Theory
- Number Systems Part-A
- Number Systems Part-B
- Number Systems Part-C
- Number Systems Part-D........ Soo many number systems!

**Number Theory:**
- Number Theory Part-A
- Number Theory Part-B
- Number Theory Part-C

**Object-Oriented Programming:**
- Introduction
- this Keyword & Constructor
- Properties of OOP
- Encapsulation
- Abstraction
- Inheritance
- Polymorphism
- Interfaces
- Abstract Classes
- Overloading and Overriding
- Constructors
- Access Modifiers
- Exception Handling
- Multithreading
- Collections Framework
- Java I/O
- Java Serialization
- Java Reflection
- Java Garbage Collection
- Java Memory Management
- Java Concurrency
- Java NIO
- Java Networking
- Java Database Access
- Java XML
- Java Internationalization
- Java Internationalization API
- Java Internationalization and Localization
- Java Internationalization and Localization API
- Java Internationalization and Localization Best Practices
- Java Internationalization and Localization Tools and Libraries

**Dynamic Programming:**
-Introduction to DP
  - Dynamic Programming is a technique used to solve problems by breaking them down into smaller subproblems and solving them independently.
  - Dynamic Programming is often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Dynamic Programming is often used in problems that can be broken down into subproblems and solved independently.
  - Dynamic Programming is often used in problems that have overlapping subproblems.
  - Dynamic Programming is often used in problems that have a large number of subproblems.
  - Dynamic Programming is often used in problems that have a large number of possible solutions.
  - Dynamic Programming is often used in problems that have a large number of states.
  - Dynamic Programming is often used in problems that have a large number of constraints.
  - Dynamic Programming is often used in problems that have a large number of variables.
  - Dynamic Programming is often used in problems that have a large number of input values.
  - Dynamic Programming is often used in problems that have a large number of output values.
  - Dynamic Programming is often used in problems that have a large number of intermediate values.
  - Dynamic Programming is often used in problems that have a large number of subproblems.


**Greedy Algorithms:**
- Introduction to Greedy Algorithms
  - Greedy Algorithms are a type of algorithmic paradigm that follows the principle of making the locally optimal choice at each step.
  - Greedy Algorithms are often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Greedy Algorithms are often used in problems that can be broken down into subproblems and solved independently.
  - Greedy Algorithms are often used in problems that have overlapping subproblems.
  - Greedy Algorithms are often used in problems that have a large number of subproblems.
  - Greedy Algorithms are often used in problems that have a large number of possible solutions.
  - Greedy Algorithms are often used in problems that have a large number of states.
  - Greedy Algorithms are often used in problems that have a large number of constraints.
  - Greedy Algorithms are often used in problems that have a large number of variables.
  - Greedy Algorithms are often used in problems that have a large number of input values.
  - Greedy Algorithms are often used in problems that have a large number of output values.
  - Greedy Algorithms are often used in problems that have a large number of intermediate values.
  - Greedy Algorithms are often used in problems that have a large number of subproblems.
  - Greedy Algorithms are often used in problems that have a large number of choices.

**Priority Queues:**
- Introduction to Priority Queues
  - Priority Queues are a type of data structure that stores a collection of elements in a specific order.
  - Priority Queues are often used in scheduling algorithms, where the goal is to find the task with the highest priority.
  - Priority Queues are often used in graph algorithms, where the goal is to find the shortest path or the lowest cost.
  - Priority Queues are often used in sorting algorithms, where the goal is to arrange the elements in ascending or descending order.
  - Priority Queues are often used in algorithms that need to process elements in a specific order.

**Advanced concepts apart from interviews:**
- Fast IO
- File handling
- Bitwise + DP
- Extended Euclidean algorithm
- Modulo Multiplicative Inverse
- Linear Diophantine Equations
- Matrix Exponentiation
- Mathematical Expectation
- Catalan Numbers
- Fermat’s Theorem
- Wilson's Theorem
- Euler's Theorem
- Lucas Theorem
- Chinese Remainder Theorem
- Euler Totient
- NP-Completeness
- Multithreading
- Fenwick Tree / Binary Indexed Tree
- Square Root Decomposition
- Sparse Table
- Sieve of Eratosthenes
- Segment Tree
- Binary Exponentiation
- Catalan Number
- Matrix Exponentiation
- Binary Exponentiation

 -------------------------------------------------------------------------------------------------------

**Version Control (Git):** Git is a version control system that is crucial for managing code and collaboration in machine learning projects. It allows you to track changes, collaborate with others, and maintain the integrity of your codebase, making it an essential tool for any machine learning engineer.

Essential Concepts:
- Setup and Configuration: init, clone, config 
- Staging: status, add, rm, mv, commit, reset
- Inspect and Compare: log, diff, show
- Branching: branch, checkout, merge
- Remote Repositories: remote, fetch, pull, push 
- Temporary Commits: stash
- GitHub: fork, pull request, code review

----------------------------------------------------------------------------------------------------------------------

**Structured Query Language:** SQL is a programming language that is crucial for managing and querying large datasets in machine learning projects. It enables you to efficiently extract and manipulate data, making it an essential skill for any machine learning engineer.

**Essential Concepts:**
- Basic Operations
- Querying data SELECT 
- Modifying data INSERT, UPDATE, DELETE 
- Filtering data WHERE, IN, BETWEEN, LIKE, IS NULL, REGEXP 
- Logical operators AND, OR, NOT 
- Sorting and limiting data ORDER BY, LIMIT 
- Complex Queries
- Joins INNER, OUTER, SELF, NATURAL, CROSS 
- Aggregate functions MAX, MIN, AVG, SUM, COUNT 
- Grouping data GROUP BY, HAVING, ROLLUP 
- Subqueries 
- Views 
- Stored Procedures and Functions 
- Triggers and Events 
- Transactions 
- Transaction isolation levels 
- BEGIN, COMMIT, ROLLBACK 
- Database Design 
- Normalization
- Database integrity with primary keys, foreign keys, and constraints 
- Indexing and Indexes
- Security and Permissions: Managing users and privileges

---------------------------------------------------------------------------------------------------------