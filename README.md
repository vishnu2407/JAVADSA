# Data Structures and Algorithms

This repository contains the code for various data structures and algorithms in Java. The code is well commented and explained in detail. The repository is divided into different sections, each containing the code for a particular data structure or algorithm. 

The repository has three sections: Arrays, Linked Lists, and Hashmap. Each section contains the code for a particular data structure or algorithm. The code is well commented and explained in detail. The code is also tested and verified to ensure its correctness.

**Data Structures and Algorithms:**
- Arrays
- Linked Lists
- Hashmap
- Heaps
- Stack
- Queues
- Trees
- Binary Tree
- Binary Search Tree
- AVL Tree
- Red-Black Tree
- Trie
- Graphs
- Searching & Sorting
- Recursion
- Backtracking In Java
- Maths for DSA
- Number Theory
- Object-Oriented Programming
- Dynamic Programming
- Greedy Algorithms
- Divide and Conquer Algorithms
- Backtracking Algorithms
- Depth-First Search (DFS)
- Breadth-First Search (BFS)
- Minimum Spanning Tree (MST)
- Prim's Algorithm
- Kruskal's Algorithm
- Dijkstra's Algorithm
- Bellman-Ford Algorithm
- Floyd-Warshall Algorithm
- Kadane's Algorithm
- Longest Common Subsequence (LCS)
- Longest Increasing Subsequence (LIS)
- Longest Common Prefix (LCP)
- Longest Palindromic Substring (LPS)
- Longest Bitonic Subsequence (LBS)
- Longest Bitonic Subarray (LBA)
- Longest Path in a Matrix (LPM)
- Longest Path in a DAG (LPD)
- Longest Path in a Tree (LPT)
- Longest Path in a Binary Tree (LPB)
- Longest Path in a Tree (LPT)
- Longest Path in a DAG (LPD)
- Longest Path in a Matrix (LPM)


**Arrays**:
- Introduction to Arrays
- ArrayList In Java
- Printing Patterns
- Boyer-Moore Majority Voting Algorithm
- Sub-arrays
- Jagged Arrays
- **Time and Space Complexity Analysis of Arrays**:
  - Read: O(1)
  - Insertion: O(n)
  - Deletion: O(n)
  - Fast at reading but slow at insertion and deletion.


**Linked Lists:**
- Introduction to Data Structures
- Introduction to Linked List
- Read: O(n)
- Insertion: O(1)
- Deletion: O(1)
- Slow at reading but efficient for insertion and deletion.

**Hashmap:**
Introduction to Hashmap
- Read: O(1)
- Insertion: O(1)
- Deletion: O(1)
- Similar to arrays but with named indexes (keys); unordered but provide fast lookup.
- Useful for tasks like dictionary implementations.
- Hashmaps are often used in caching, where the data is frequently accessed and the cost of accessing the data is high.
- Hashmaps are also used in database indexing, where the data is frequently searched and the cost of searching the data is high.
- Hashmaps are also used in data structures like sets and maps, where the data is frequently searched and the cost of searching the data is high.
- Hashmaps are also used in algorithms like BFS and DFS, where the data is frequently accessed and the cost of accessing the data is high.

**Heaps:**
Introduction to Heaps
- A data structure that stores a collection of elements in a specific order.
- Heaps are useful for tasks like sorting, graph algorithms, and scheduling.
- Heaps are often implemented using an array or a binary tree.
- Heaps can be used to implement priority queues, which are often used in scheduling algorithms.
- Heaps can be used to implement heapsort, which is a popular sorting algorithm.
- Heaps can be used to implement Dijkstra's shortest path algorithm, which is a popular graph algorithm.
- Heaps can be used to implement the heap data structure used in the heapsort algorithm.

**Intro to Stack**:
- Push: O(1)
- Pop: O(1)
- Peak: O(1)
- Follow the LIFO (Last In, First Out) principle; useful for fast retrieval of the topmost element but can be cumbersome for inserting or deleting elements in the middle or end.

**Intro to Queues**:
- Enqueue: O(1)
- Dequeue: O(1)
- Front: O(1)
- Follow the FIFO (First In, First Out) principle; the first element in line is the first to come out. Think of them as playlists for organizing items in order of arrival.


**Trees:**
Intro to Trees
- Read/Search: O(log n)
- Insertion: O(log n)
- Deletion: O(log n)
- Nodes connected by edges; root, parent-child connections.


**Binary Tree:**
Intro to Binary Tree
- Efficient searching of ordered values.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Useful for tasks like number guessing games or dictionary implementations.


**Binary Search Tree:**
Intro to BST
- Efficient searching of ordered values.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Useful for tasks like number guessing games or dictionary implementations.

**AVL Tree:**
Introduction to AVL Tree
- A self-balancing binary search tree.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Balancing is done by maintaining a balance factor for each node.
- AVL Tree is a good choice for balanced trees.

**Red-Black Tree:**
Introduction to Red-Black Tree
- A self-balancing binary search tree.
- Follow a binary search property where left child nodes are less than the parent and right child nodes are greater.
- Balancing is done by maintaining a balance factor for each node.
- Red-Black Tree is a good choice for balanced trees.

**Trie:**
Introduction to Trie
- A tree-like data structure used for efficient string searching.
- Each node represents a character in the string.
- Each edge represents a character.
- The root represents an empty string.
- The leaf nodes represent the end of a string.
- Tries are useful for tasks like autocomplete or spell checking.
- Tries are also used in spell checking and autocomplete.
- Tries are also used in autocomplete to suggest words based on the characters entered so far.
- Tries are also used in spell checking to suggest corrections based on the misspelled word.
- Tries are a type of data structure that is used for efficient string searching.
- Tries are often used in autocomplete to suggest words based on the characters entered so far.
- Tries are often used in tasks like routing, social networks, and pathfinding.



**Graphs:**
Introduction to Graphs
- Traversal/Search: O(V + E) (V: number of vertices, E: number of edges)
- Insertion: O(1)
- Deletion: O(1)
- Versatile models for connections between nodes and edges; can be directed or undirected with no neighboring limit. Can include cycles and weights on paths. Used for tasks like route optimization.
- Graphs are used in tasks like routing, social networks, and pathfinding.
- Graphs are used in tasks like clustering, community detection, and recommendation systems.
- Graphs are used in tasks like social networks, routing, and pathfinding.
- Graphs are used in tasks like clustering, community detection, and recommendation systems.
- Graphs are used in tasks like social networks, routing, and pathfinding.


**Searching & Sorting:**
- Linear Search
- Binary Search
- Bubble Sort
- Selection Sort
- Insertion Sort
- Count Sort
- Radix Sort
- Cyclic Sort
- Practise Questions

**Space & Time Complexity Analysis:**
- Time Complexity
- Space Complexity
- Recurrence Relations
- Time Space Tradeoff

**Recursion:**
- Intro to Recursion
- Flow of Recursion & Array
- Recursion & Strings
- Merge Sort
- Quick Sort
- Standard Practise Questions

**BackTracking In Java:**
Introduction to Backtracking
Sudoku Solver
- N Queens
- N Knight
- Maze Problems

**Maths for DSA:**
- Introduction to Maths in DSA
- Complete Bitwise Operators
- Modulo Arithmetic
- GCD and LCM
- Prime Numbers
- Euclid's Algorithm
- Euler's Totient Function
- Fibonacci Numbers
- Factorial
- Combinatorics
- Probability and Statistics
- Number Systems
- Number Theory
- Linear Algebra
- Complex Numbers
- Trigonometry
- Graph Theory
- Number Systems Part-A
- Number Systems Part-B
- Number Systems Part-C
- Number Systems Part-D........ Soo many number systems!

**Number Theory:**
- Number Theory Part-A
- Number Theory Part-B
- Number Theory Part-C

**Object-Oriented Programming:**
- Introduction
- this Keyword & Constructor
- Properties of OOP
- Encapsulation
- Abstraction
- Inheritance
- Polymorphism
- Interfaces
- Abstract Classes
- Overloading and Overriding
- Constructors
- Access Modifiers
- Exception Handling
- Multithreading
- Collections Framework
- Java I/O
- Java Serialization
- Java Reflection
- Java Garbage Collection
- Java Memory Management
- Java Concurrency
- Java NIO
- Java Networking
- Java Database Access
- Java XML
- Java Internationalization
- Java Internationalization API
- Java Internationalization and Localization
- Java Internationalization and Localization API
- Java Internationalization and Localization Best Practices
- Java Internationalization and Localization Tools and Libraries

**Dynamic Programming:**
-Introduction to DP
  - Dynamic Programming is a technique used to solve problems by breaking them down into smaller subproblems and solving them independently.
  - Dynamic Programming is often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Dynamic Programming is often used in problems that can be broken down into subproblems and solved independently.
  - Dynamic Programming is often used in problems that have overlapping subproblems.
  - Dynamic Programming is often used in problems that have a large number of subproblems.
  - Dynamic Programming is often used in problems that have a large number of possible solutions.
  - Dynamic Programming is often used in problems that have a large number of states.
  - Dynamic Programming is often used in problems that have a large number of constraints.
  - Dynamic Programming is often used in problems that have a large number of variables.
  - Dynamic Programming is often used in problems that have a large number of input values.
  - Dynamic Programming is often used in problems that have a large number of output values.
  - Dynamic Programming is often used in problems that have a large number of intermediate values.
  - Dynamic Programming is often used in problems that have a large number of subproblems.


**Greedy Algorithms:**
- Introduction to Greedy Algorithms
  - Greedy Algorithms are a type of algorithmic paradigm that follows the principle of making the locally optimal choice at each step.
  - Greedy Algorithms are often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Greedy Algorithms are often used in problems that can be broken down into subproblems and solved independently.
  - Greedy Algorithms are often used in problems that have overlapping subproblems.
  - Greedy Algorithms are often used in problems that have a large number of subproblems.
  - Greedy Algorithms are often used in problems that have a large number of possible solutions.
  - Greedy Algorithms are often used in problems that have a large number of states.
  - Greedy Algorithms are often used in problems that have a large number of constraints.
  - Greedy Algorithms are often used in problems that have a large number of variables.
  - Greedy Algorithms are often used in problems that have a large number of input values.
  - Greedy Algorithms are often used in problems that have a large number of output values.
  - Greedy Algorithms are often used in problems that have a large number of intermediate values.
  - Greedy Algorithms are often used in problems that have a large number of subproblems.
  - Greedy Algorithms are often used in problems that have a large number of choices.

**Divide and Conquer Algorithms:**
- Introduction to Divide and Conquer Algorithms
  - Divide and Conquer Algorithms are a type of algorithmic paradigm that breaks down a problem into smaller subproblems and solves them independently.
  - Divide and Conquer Algorithms are often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Divide and Conquer Algorithms are often used in problems that can be broken down into subproblems and solved independently.
  - Divide and Conquer Algorithms are often used in problems that have overlapping subproblems.
  - Divide and Conquer Algorithms are often used in problems that have a large number of subproblems.
  - Divide and Conquer Algorithms are often used in problems that have a large number of possible solutions.
  - Divide and Conquer Algorithms are often used in problems that have a large number of states.
  - Divide and Conquer Algorithms are often used in problems that have a large number of constraints.
  - Divide and Conquer Algorithms are often used in problems that have a large number of variables.
  - Divide and Conquer Algorithms are often used in problems that have a large number of input values.
  - Divide and Conquer Algorithms are often used in problems that have a large number of output values.
  - Divide and Conquer Algorithms are often used in problems that have a large number of intermediate values.
  - Divide and Conquer Algorithms are often used in problems that have a large number of subproblems.
  - Divide and Conquer Algorithms are often used in problems that have a large number of choices.

**Backtracking Algorithms:**
- Introduction to Backtracking Algorithms
  - Backtracking Algorithms are a type of algorithmic paradigm that tries to find a solution by exploring all possible paths and then backtracks to the previous state if it determines that the current state is not a solution.
  - Backtracking Algorithms are often used in optimization problems, where the goal is to find the best solution among a set of possible solutions.
  - Backtracking Algorithms are often used in problems that can be broken down into subproblems and solved independently.
  - Backtracking Algorithms are often used in problems that have overlapping subproblems.
  - Backtracking Algorithms are often used in problems that have a large number of subproblems.
  - Backtracking Algorithms are often used in problems that have a large number of possible solutions.
  - Backtracking Algorithms are often used in problems that have a large number of states.
  - Backtracking Algorithms are often used in problems that have a large number of constraints.
  - Backtracking Algorithms are often used in problems that have a large number of variables.
  - Backtracking Algorithms are often used in problems that have a large number of input values.
  - Backtracking Algorithms are often used in problems that have a large number of output values.
  - Backtracking Algorithms are often used in problems that have a large number of intermediate values.
  - Backtracking Algorithms are often used in problems that have a large number of subproblems.
  - Backtracking Algorithms are often used in problems that have a large number of choices.

**Depth-First Search (DFS):**
- Introduction to Depth-First Search (DFS)
  - Depth-First Search (DFS) is a type of graph traversal algorithm that visits all the vertices in a graph by traversing as far as possible along each branch before backtracking.
  - Depth-First Search (DFS) is often used in problems that require traversing a graph.
  - Depth-First Search (DFS) is often used in problems that have a large number of vertices and edges.
  - Depth-First Search (DFS) is often used in problems that have a large number of possible solutions.
  - Depth-First Search (DFS) is often used in problems that have a large number of states.
  - Depth-First Search (DFS) is often used in problems that have a large number of constraints.
  - Depth-First Search (DFS) is often used in problems that have a large number of variables.
  - Depth-First Search (DFS) is often used in problems that have a large number of input values.
  - Depth-First Search (DFS) is often used in problems that have a large number of output values.
  - Depth-First Search (DFS) is often used in problems that have a large number of intermediate values.
  - Depth-First Search (DFS) is often used in problems that have a large number of subproblems.
  - Depth-First Search (DFS) is often used in problems that have a large number of choices.

**Breadth-First Search (BFS):**
- Introduction to Breadth-First Search (BFS)
  - Breadth-First Search (BFS) is a type of graph traversal algorithm that visits all the vertices in a graph by traversing as far as possible along each branch before backtracking.
  - Breadth-First Search (BFS) is often used in problems that require traversing a graph.
  - Breadth-First Search (BFS) is often used in problems that have a large number of vertices and edges.
  - Breadth-First Search (BFS) is often used in problems that have a large number of possible solutions.
  - Breadth-First Search (BFS) is often used in problems that have a large number of states.
  - Breadth-First Search (BFS) is often used in problems that have a large number of constraints.
  - Breadth-First Search (BFS) is often used in problems that have a large number of variables.
  - Breadth-First Search (BFS) is often used in problems that have a large number of input values.
  - Breadth-First Search (BFS) is often used in problems that have a large number of output values.
  - Breadth-First Search (BFS) is often used in problems that have a large number of intermediate values.
  - Breadth-First Search (BFS) is often used in problems that have a large number of subproblems.
  - Breadth-First Search (BFS) is often used in problems that have a large number of choices.

**Topological Sort:**
- Introduction to Topological Sort
  - Topological Sort is a type of algorithmic paradigm that sorts a DAG (Directed Acyclic Graph) in such a way that all the vertices are in a linear order.
  - Topological Sort is often used in problems that require sorting a DAG.
  - Topological Sort is often used in problems that have a large number of vertices and edges.
  - Topological Sort is often used in problems that have a large number of possible solutions.
  - Topological Sort is often used in problems that have a large number of states.
  - Topological Sort is often used in problems that have a large number of constraints.
  - Topological Sort is often used in problems that have a large number of variables.
  - Topological Sort is often used in problems that have a large number of input values.
  - Topological Sort is often used in problems that have a large number of output values.
  - Topological Sort is often used in problems that have a large number of intermediate values.
  - Topological Sort is often used in problems that have a large number of subproblems.
  - Topological Sort is often used in problems that have a large number of choices.

**Minimum Spanning Tree (MST):**
- Introduction to Minimum Spanning Tree (MST)
  - Minimum Spanning Tree (MST) is a type of algorithmic paradigm that finds a subset of edges that connects all the vertices in a graph with the smallest possible total weight.
  - Minimum Spanning Tree (MST) is often used in problems that require finding a subset of edges that connects all the vertices in a graph with the smallest possible total weight.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of vertices and edges.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of possible solutions.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of states.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of constraints.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of variables.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of input values.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of output values.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of intermediate values.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of subproblems.
  - Minimum Spanning Tree (MST) is often used in problems that have a large number of choices.

**Kruskal's Algorithm:**
- Introduction to Kruskal's Algorithm
  - Kruskal's Algorithm is a type of algorithmic paradigm that finds a minimum spanning tree (MST) of a connected, undirected graph.
  - Kruskal's Algorithm is often used in problems that require finding a MST of a connected, undirected graph.
  - Kruskal's Algorithm is often used in problems that have a large number of vertices and edges.
  - Kruskal's Algorithm is often used in problems that have a large number of possible solutions.
  - Kruskal's Algorithm is often used in problems that have a large number of states.
  - Kruskal's Algorithm is often used in problems that have a large number of constraints.
  - Kruskal's Algorithm is often used in problems that have a large number of variables.
  - Kruskal's Algorithm is often used in problems that have a large number of input values.
  - Kruskal's Algorithm is often used in problems that have a large number of output values.
  - Kruskal's Algorithm is often used in problems that have a large number of intermediate values.
  - Kruskal's Algorithm is often used in problems that have a large number of subproblems.
  - Kruskal's Algorithm is often used in problems that have a large number of choices.
  - Kruskal's Algorithm is often used in problems that have a large number of edges.

  **Prim's Algorithm:**
- Introduction to Prim's Algorithm
  - Prim's Algorithm is a type of algorithmic paradigm that finds a minimum spanning tree (MST) of a connected, undirected graph.
  - Prim's Algorithm is often used in problems that require finding a MST of a connected, undirected graph.
  - Prim's Algorithm is often used in problems that have a large number of vertices and edges.
  - Prim's Algorithm is often used in problems that have a large number of possible solutions.
  - Prim's Algorithm is often used in problems that have a large number of states.
  - Prim's Algorithm is often used in problems that have a large number of constraints.
  - Prim's Algorithm is often used in problems that have a large number of variables.
  - Prim's Algorithm is often used in problems that have a large number of input values.
  - Prim's Algorithm is often used in problems that have a large number of output values.
  - Prim's Algorithm is often used in problems that have a large number of intermediate values.
  - Prim's Algorithm is often used in problems that have a large number of subproblems.
  - Prim's Algorithm is often used in problems that have a large number of choices.
  - Prim's Algorithm is often used in problems that have a large number of edges.

**Advanced concepts apart from interviews:**
- Fast IO
- File handling
- Bitwise + DP
- Extended Euclidean algorithm
- Modulo Multiplicative Inverse
- Linear Diophantine Equations
- Matrix Exponentiation
- Mathematical Expectation
- Catalan Numbers
- Fermat’s Theorem
- Wilson's Theorem
- Euler's Theorem
- Lucas Theorem
- Chinese Remainder Theorem
- Euler Totient
- NP-Completeness
- Multithreading
- Fenwick Tree / Binary Indexed Tree
- Square Root Decomposition
- Sparse Table
- Sieve of Eratosthenes
- Segment Tree
- Binary Exponentiation
- Catalan Number
- Matrix Exponentiation
- Binary Exponentiation

 -------------------------------------------------------------------------------------------------------

**Version Control (Git):** Git is a version control system that is crucial for managing code and collaboration in machine learning projects. It allows you to track changes, collaborate with others, and maintain the integrity of your codebase, making it an essential tool for any machine learning engineer.

Essential Concepts:
- Setup and Configuration: init, clone, config 
- Staging: status, add, rm, mv, commit, reset
- Inspect and Compare: log, diff, show
- Branching: branch, checkout, merge
- Remote Repositories: remote, fetch, pull, push 
- Temporary Commits: stash
- GitHub: fork, pull request, code review

----------------------------------------------------------------------------------------------------------------------

**Structured Query Language:** SQL is a programming language that is crucial for managing and querying large datasets in machine learning projects. It enables you to efficiently extract and manipulate data, making it an essential skill for any machine learning engineer.

**Essential Concepts:**
- Basic Operations
- Querying data SELECT 
- Modifying data INSERT, UPDATE, DELETE 
- Filtering data WHERE, IN, BETWEEN, LIKE, IS NULL, REGEXP 
- Logical operators AND, OR, NOT 
- Sorting and limiting data ORDER BY, LIMIT 
- Complex Queries
- Joins INNER, OUTER, SELF, NATURAL, CROSS 
- Aggregate functions MAX, MIN, AVG, SUM, COUNT 
- Grouping data GROUP BY, HAVING, ROLLUP 
- Subqueries 
- Views 
- Stored Procedures and Functions 
- Triggers and Events 
- Transactions 
- Transaction isolation levels 
- BEGIN, COMMIT, ROLLBACK 
- Database Design 
- Normalization
- Database integrity with primary keys, foreign keys, and constraints 
- Indexing and Indexes
- Security and Permissions: Managing users and privileges

---------------------------------------------------------------------------------------------------------